import argparse
import math
import secrets
import string
import sys

try:
    import pyperclip
    HAS_PYPERCLIP = True
except Exception:
    HAS_PYPERCLIP = False

LOWER = string.ascii_lowercase
UPPER = string.ascii_uppercase
DIGITS = string.digits
SYMBOLS = "!@#$%^&*()-_=+[]{};:,.<>?/|\\"
AMBIGUOUS = "Il1O0"

def build_charset(use_lower=True, use_upper=True, use_digits=True, use_symbols=True, exclude_ambiguous=False):
    s = ""
    if use_lower:
        s += LOWER
    if use_upper:
        s += UPPER
    if use_digits:
        s += DIGITS
    if use_symbols:
        s += SYMBOLS
    if exclude_ambiguous:
        s = "".join(ch for ch in s if ch not in AMBIGUOUS)
    if not s:
        raise ValueError("Character set is empty.")
    return s

def generate_password(length=16, require_each_class=False, **charset_kwargs):
    charset = build_charset(**charset_kwargs)
    if length <= 0:
        raise ValueError("Length must be positive")
    if require_each_class:
        required = []
        if charset_kwargs.get("use_lower", True):
            required.append(secrets.choice(LOWER if not charset_kwargs.get("exclude_ambiguous", False) else "".join(ch for ch in LOWER if ch not in AMBIGUOUS)))
        if charset_kwargs.get("use_upper", True):
            required.append(secrets.choice(UPPER if not charset_kwargs.get("exclude_ambiguous", False) else "".join(ch for ch in UPPER if ch not in AMBIGUOUS)))
        if charset_kwargs.get("use_digits", True):
            required.append(secrets.choice(DIGITS if not charset_kwargs.get("exclude_ambiguous", False) else "".join(ch for ch in DIGITS if ch not in AMBIGUOUS)))
        if charset_kwargs.get("use_symbols", True):
            required.append(secrets.choice(SYMBOLS if not charset_kwargs.get("exclude_ambiguous", False) else "".join(ch for ch in SYMBOLS if ch not in AMBIGUOUS)))
        if len(required) > length:
            raise ValueError("Length too short")
        remaining = [secrets.choice(charset) for _ in range(length - len(required))]
        pw_chars = required + remaining
        secrets.SystemRandom().shuffle(pw_chars)
        return "".join(pw_chars)
    else:
        return "".join(secrets.choice(charset) for _ in range(length))

def entropy_bits_for_password(length, charset_size):
    if charset_size <= 1:
        return 0.0
    return length * math.log2(charset_size)

def strength_label(entropy_bits):
    if entropy_bits < 28:
        return "Very Weak"
    if entropy_bits < 36:
        return "Weak"
    if entropy_bits < 60:
        return "Reasonable"
    if entropy_bits < 80:
        return "Strong"
    return "Very Strong"

def load_wordlist(path):
    with open(path, "r", encoding="utf-8") as f:
        words = [w.strip() for w in f if w.strip()]
    return words

def generate_passphrase(num_words=4, wordlist=None, separator="-", capitalize=False):
    if wordlist is None or len(wordlist) == 0:
        raise ValueError("Wordlist must be provided")
    words = []
    for _ in range(num_words):
        w = secrets.choice(wordlist)
        words.append(w.capitalize() if capitalize else w)
    phrase = separator.join(words)
    entropy = num_words * math.log2(len(set(wordlist)))
    return phrase, entropy

def parse_args():
    p = argparse.ArgumentParser(description="Secure Password / Passphrase Generator")
    sub = p.add_subparsers(dest="mode", required=True)

    gen = sub.add_parser("password", help="Generate a random password")
    gen.add_argument("-l", "--length", type=int, default=16)
    gen.add_argument("--no-lower", action="store_true")
    gen.add_argument("--no-upper", action="store_true")
    gen.add_argument("--no-digits", action="store_true")
    gen.add_argument("--no-symbols", action="store_true")
    gen.add_argument("--exclude-ambiguous", action="store_true")
    gen.add_argument("--require-each", action="store_true")
    gen.add_argument("--copy", action="store_true")

    passp = sub.add_parser("passphrase", help="Generate a passphrase")
    passp.add_argument("-n", "--num-words", type=int, default=4)
    passp.add_argument("-w", "--wordlist", type=str, required=True)
    passp.add_argument("-s", "--sep", default="-")
    passp.add_argument("--capitalize", action="store_true")
    passp.add_argument("--copy", action="store_true")

    return p.parse_args()

def main():
    args = parse_args()
    if args.mode == "password":
        charset_kwargs = {
            "use_lower": not args.no_lower,
            "use_upper": not args.no_upper,
            "use_digits": not args.no_digits,
            "use_symbols": not args.no_symbols,
            "exclude_ambiguous": args.exclude_ambiguous
        }
        pw = generate_password(length=args.length, require_each_class=args.require_each, **charset_kwargs)
        charset_size = len(build_charset(**charset_kwargs))
        entropy = entropy_bits_for_password(len(pw), charset_size)
        print(pw)
        print(f"Entropy: {entropy:.1f} bits ({strength_label(entropy)})")
        if args.copy:
            if not HAS_PYPERCLIP:
                print("pyperclip not installed", file=sys.stderr)
            else:
                pyperclip.copy(pw)
                print("Password copied.")
    elif args.mode == "passphrase":
        try:
            wl = load_wordlist(args.wordlist)
        except Exception as e:
            print(f"Failed to load wordlist: {e}", file=sys.stderr)
            sys.exit(2)
        phrase, entropy = generate_passphrase(num_words=args.num_words, wordlist=wl, separator=args.sep, capitalize=args.capitalize)
        print(phrase)
        print(f"Entropy: {entropy:.1f} bits ({strength_label(entropy)})")
        if args.copy:
            if not HAS_PYPERCLIP:
                print("pyperclip not installed", file=sys.stderr)
            else:
                pyperclip.copy(phrase)
                print("Passphrase copied.")

if __name__ == "__main__":
    main()
